
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Data Manipulation Modules &#8212; PyAvia 0.0.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Fortran" href="pyavia.fortran.html" />
    <link rel="prev" title="Containers" href="pyavia.containers.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyavia.fortran.html" title="Fortran"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pyavia.containers.html" title="Containers"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyAvia 0.0.4 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Data Manipulation Modules</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-manipulation-modules">
<span id="pyavia-data"></span><h1>Data Manipulation Modules<a class="headerlink" href="#data-manipulation-modules" title="Permalink to this headline">¶</a></h1>
<section id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
<p><strong>Filtering</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyavia.data.J211_2pole" title="pyavia.data.J211_2pole"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyavia.data.J211_2pole</span></code></a></p></td>
<td><p>This a 2-pole Butterworth filter, implemented using the exact algorithm of SAE J211-1 Appendix C.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyavia.data.J211_4pole" title="pyavia.data.J211_4pole"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyavia.data.J211_4pole</span></code></a></p></td>
<td><p>This a 4-pole phaseless Butterworth filter, implemented using the exact algorithm of SAE J211-1 Appendix C.</p></td>
</tr>
</tbody>
</table>
<p><strong>Interpolation</strong></p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyavia.data.Interp2Level" title="pyavia.data.Interp2Level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyavia.data.Interp2Level</span></code></a></p></td>
<td><p>Two step interpolator based on SciPy interp1d, for interpolating data where multiple single-Y-valued curves are given.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyavia.data.linear_int_ext" title="pyavia.data.linear_int_ext"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyavia.data.linear_int_ext</span></code></a></p></td>
<td><p>Interpolate data points to find remaining unknown values absent from <cite>p</cite> with optionally scaled axes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyavia.data.smooth_array2d" title="pyavia.data.smooth_array2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyavia.data.smooth_array2d</span></code></a></p></td>
<td><p>Produces a new 2D array by doing 1D interpolation of rows / columns in given input array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyavia.data.smooth_multi" title="pyavia.data.smooth_multi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyavia.data.smooth_multi</span></code></a></p></td>
<td><p>Smooth multiple equal-length arrays / lists <cite>y</cite> (dependent variables) using interpolation / extrapolation, taking <cite>x</cite> as the independent variable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyavia.data.subd_num_list" title="pyavia.data.subd_num_list"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyavia.data.subd_num_list</span></code></a></p></td>
<td><p>Expands a sorted list of values by repeatedly subdividing the intervals in the initial list, stopping before <cite>max_size</cite> is exceeded.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-pyavia.data">
<span id="members"></span><h2>Members<a class="headerlink" href="#module-pyavia.data" title="Permalink to this headline">¶</a></h2>
<p>Functions relating to data manipulation, interpolation, filtering, et cetera.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyavia.data.Interp2Level">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyavia.data.</span></span><span class="sig-name descname"><span class="pre">Interp2Level</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_lvls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl_vals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_bounds_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl_kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl_bounds_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl_fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_sorted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyavia.data.Interp2Level" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Two step interpolator based on SciPy interp1d, for interpolating data
where multiple single-Y-valued curves are given.  Interpolation
proceeds as follows for an intermediate level:</p>
<ul class="simple">
<li><p>A parameterised curve is generated from the provided data on either
side.</p></li>
<li><p>The parameterised curve is interrogated for the specific X-value
required.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="pyavia.data.Interp2Level.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyavia.data.Interp2Level.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the interpolated value.  Similar to implemention in
SciPy _Interpolator1D, except we require both an <cite>x</cite> and level
curve value (or sequence of values).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Data for each level curve may not overlap the required
area.  Points where interpolation are not available are simply
excluded from the second level of interpolation and we attempt to
continue.  This could cause higher order interpolations to fail
if there are insufficient points remaining.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array_like</em>) – <cite>x</cite> values where interpolation is required.</p></li>
<li><p><strong>lvl</strong> (<em>array_like</em>) – Level curve values where interpolation is required. Requires
len(<cite>x</cite>) == len(<cite>y</cite>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – Interpolated values. Shape is determined by replacing
the interpolation axis in the original array with the shape of
<cite>x</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyavia.data.Interp2Level.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_lvls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl_vals</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_bounds_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl_kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl_bounds_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lvl_fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_sorted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyavia.data.Interp2Level.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>array_like</em>) – A 1-D array of <cite>x</cite> real values.</p></li>
<li><p><strong>y_lvls</strong> (<em>(</em><em>N</em><em>,</em><em>M</em><em>) </em><em>array_like</em>) – <p>A <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">M</span></code> array of real values, where columns represent the <cite>y</cite>
data at different values of the level curves:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code> must equal to the length of <cite>x</cite>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">M</span></code> must equal to the length of <cite>val_lvl</cite>.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>lvl_vals</strong> (<em>(</em><em>M</em><em>,</em><em>) </em><em>array_like</em>) – A 1-D array of values corresponding to each level curve.
Minimum <cite>M</cite> = 2.</p></li>
<li><p><strong>y_kind</strong> – Interpolation kind, bounds handling and fill value to
use during the first interpolation step along level curves.
For details refer to SciPy interp1d.</p></li>
<li><p><strong>y_bounds_error</strong> – Interpolation kind, bounds handling and fill value to
use during the first interpolation step along level curves.
For details refer to SciPy interp1d.</p></li>
<li><p><strong>y_fill_value</strong> – Interpolation kind, bounds handling and fill value to
use during the first interpolation step along level curves.
For details refer to SciPy interp1d.</p></li>
<li><p><strong>lvl_kind</strong> – Interpolation kind, bounds handling and fill value to
use during the second interpolation step between level curves.
For details refer to SciPy interp1d.</p></li>
<li><p><strong>lvl_bounds_error</strong> – Interpolation kind, bounds handling and fill value to
use during the second interpolation step between level curves.
For details refer to SciPy interp1d.</p></li>
<li><p><strong>lvl_fill_value</strong> – Interpolation kind, bounds handling and fill value to
use during the second interpolation step between level curves.
For details refer to SciPy interp1d.</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Refer to SciPy interp1d.</p></li>
<li><p><strong>assume_sorted</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Refer to SciPy interp1d.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyavia.data.J211_2pole">
<span class="sig-prename descclassname"><span class="pre">pyavia.data.</span></span><span class="sig-name descname"><span class="pre">J211_2pole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CFC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwd_pass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyavia.data.J211_2pole" title="Permalink to this definition">¶</a></dt>
<dd><p>This a 2-pole Butterworth filter, implemented using the exact algorithm of
SAE J211-1 Appendix C.  This algorithm is designed for filtering impact
test data and does not rely on <cite>scipy.signal</cite>.  The 2-pole filter will
phase shift the result in the direction of filtering.  See <cite>J211_4pole()</cite>
for a phaseless implementation,</p>
<p>Filter startup is acheived by directly copying the first two data points
to the output.  Filter startup effects can be avoided by having at least
10 ms of data before or after the area of interest with direction
depending on <cite>fwd_pass</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>(</em><em>N</em><em>,</em><em>…</em><em>) or </em><em>(</em><em>…</em><em>,</em><em>N</em><em>) </em><em>array_like</em>) – Input data stream as an N-D array.</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Sample period (i.e. time step) in seconds.  Typical order might be
around <cite>T</cite> = 1e-3 (i.e. milliseconds).</p></li>
<li><p><strong>CFC</strong> (<em>float</em>) – Channel Frequency Class is a number corresponding to the channel
frequency response lies and is numerically equal to <span class="math notranslate nohighlight">\(F_H\)</span>
the filter high-pass frquency (in Hz).  Examples are shown in SAE J211
Figure 1 for CFCs of 1000 and 600.</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – For N-dimensional data, this represents the time-like axis (default
<cite>axis</cite> = 0).</p></li>
<li><p><strong>fwd_pass</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – If False, the data is passed over in reverse.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Y</strong> – Filtered output data stream with shape matching <cite>X</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(N,…) or (…,N) array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyavia.data.J211_4pole">
<span class="sig-prename descclassname"><span class="pre">pyavia.data.</span></span><span class="sig-name descname"><span class="pre">J211_4pole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CFC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyavia.data.J211_4pole" title="Permalink to this definition">¶</a></dt>
<dd><p>This a 4-pole phaseless Butterworth filter, implemented using the exact
algorithm of SAE J211-1 Appendix C.  This algorithm is designed for
filtering impact test data and does not rely on <cite>scipy.signal</cite>.  The
4-pole filter is simply a forwards and backwards pass of the 2-pole
filter of the data (see <cite>J211_2pole()</cite>) for a phaseless implementation,</p>
<p>Filter startup is acheived by directly copying the first two data points
at each end to the output.  Filter startup effects can be avoided by
having at least 10 ms of data beyond each end of the area of interest.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>(</em><em>N</em><em>,</em><em>…</em><em>) or </em><em>(</em><em>…</em><em>,</em><em>N</em><em>) </em><em>array_like</em>) – Input data stream as an N-D array.</p></li>
<li><p><strong>T</strong> (<em>float</em>) – Sample period (i.e. time step) in seconds.  Typical order is around
1e-3 (milliseconds).</p></li>
<li><p><strong>CFC</strong> (<em>float</em>) – Channel Frequency Class is a number corresponding to the channel
frequency response lies and is numerically equal to <span class="math notranslate nohighlight">\(F_H\)</span>
the filter high-pass frquency (in Hz).  Examples are shown in SAE
J211 Figure 1 for CFCs of 1000 and 600.</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – For N-dimensional data, this represents the time-like axis (default
<cite>axis</cite> = 0).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Y</strong> – Filtered output data stream with shape matching <cite>X</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(N,…) or (…,N) array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyavia.data.linear_int_ext">
<span class="sig-prename descclassname"><span class="pre">pyavia.data.</span></span><span class="sig-name descname"><span class="pre">linear_int_ext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_extrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyavia.data.linear_int_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate data points to find remaining unknown values absent from
<cite>p</cite> with optionally scaled axes. If <cite>p</cite> is not in the range and
<cite>allow_extra</cite> == True, a linear extrapolation is done using the two data
points at the end corresponding to the <cite>p</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_pts</strong> (<em>list_like</em><em>(</em><em>tuple</em><em>)</em>) – [(a_1, … a_n), …] sorted on the required axis (either direction).</p></li>
<li><p><strong>p</strong> (<em>list_like</em>) – Required point to interpolate / extrapolate with at least a single
known component, i.e. <span class="math notranslate nohighlight">\((..., None, p_i, None, ...)\)</span>. If
more than one is supplied, the first is used.</p></li>
<li><p><strong>scale</strong> – Same as <code class="docutils literal notranslate"><span class="pre">line_pt</span></code> scale.</p></li>
<li><p><strong>allow_extrap</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True linear extrapolation from the two adjacent endpoints is
permitted. Default = False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Interpolated / extrapolated point <span class="math notranslate nohighlight">\([q_1, ..., q_n]\)</span> where
<span class="math notranslate nohighlight">\(q_i = p_i\)</span> from above.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyavia.data.smooth_array2d">
<span class="sig-prename descclassname"><span class="pre">pyavia.data.</span></span><span class="sig-name descname"><span class="pre">smooth_array2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_new</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyavia.data.smooth_array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a new 2D array by doing 1D interpolation of rows / columns in
given input array.  This can be used to regularise data, or make a larger
input array from a smaller amount of data.</p>
<p>The returned array is produced by interpolating <cite>arr</cite> along <cite>axis</cite>
and the other axis is unchanged.  The row / column index in <cite>x_idx</cite> is
treated as the independent variable and is replaced by  <cite>x_new</cite>.
Remaining rows / columns are interpolated as the dependent variables
(e.g. ‘y’).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
<span class="gp">... </span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 1.,  1.,  3.,  5.],</span>
<span class="go">       [ 3.,  4.,  5.,  6.],</span>
<span class="go">       [10.,  8.,  5.,  4.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smooth_array2d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_new</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">array([[ 1.        ,  1.        ,  3.        ,  5.        ],</span>
<span class="go">       [ 4.        ,  4.57142857,  5.        ,  5.71428571],</span>
<span class="go">       [ 7.        ,  6.28571429,  5.        ,  4.85714286],</span>
<span class="go">       [10.        ,  8.        ,  5.        ,  4.        ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smooth_array2d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_new</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quadratic&#39;</span><span class="p">)</span>
<span class="go">array([[ 1.        ,  1.        ,  3.        ,  5.        ],</span>
<span class="go">       [ 4.        ,  5.19047619,  5.66666667,  6.23809524],</span>
<span class="go">       [ 7.        ,  7.52380952,  6.33333333,  5.9047619 ],</span>
<span class="go">       [10.        ,  8.        ,  5.        ,  4.        ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smooth_array2d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_new</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">5.5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
<span class="go">array([[ 1.    ,  0.625 ,  1.    ,  1.875 ,  3.    ,  4.125 ,  5.    ],</span>
<span class="go">       [ 3.    ,  3.5   ,  4.    ,  4.5   ,  5.    ,  5.5   ,  6.    ],</span>
<span class="go">       [10.    ,  9.3125,  8.    ,  6.4375,  5.    ,  4.0625,  4.    ]])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>np.array</em><em> or </em><em>[</em><em>[</em><em>a</em><em>, </em><em>b</em><em>, </em><em>c</em><em>, </em><em>...</em><em>]</em><em>, </em><em>...</em><em>]</em>) – 2D array of data to be smoothed.</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – Interpolation axis.</p></li>
<li><p><strong>x_idx</strong> (<em>int</em>) – Row / column index along ‘other’ axis to treat as independent variable.</p></li>
<li><p><strong>x_new</strong> (<em>array-like</em><em> or </em><em>int</em>) – <dl class="simple">
<dt>Depending on argument type:</dt><dd><ul>
<li><p>array-like: New values replacing the previous ‘independent’
variable along <cite>array2d[:, x_idx]</cite> if <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">==</span> <span class="pre">0</span></code> or
<cite>array2d[x_idx, :]</cite> if <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p></li>
<li><p>int: Use an number of equally spaced points between min and max
values of the independent axis.  Equivalent to: <code class="docutils literal notranslate"><span class="pre">x_new</span> <span class="pre">=</span>
<span class="pre">np.linspace(np.min(x),</span> <span class="pre">np.max(x),</span> <span class="pre">num=x_new)</span></code></p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>kind</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Interpolation method to use (default = ‘linear’).  Any ‘kind’
acceptable to the underlying interpolator
<code class="docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code> can be used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sufficient data rows / columns must be available to compute
higher order interpolations <cite>quadratic</cite> or <cite>cubic</cite>, i.e. 3 and 4
respectively.</p>
</div>
</p></li>
<li><p><strong>fill_value</strong> (<em>None</em><em>, </em><em>array-like</em><em>, </em><em>(</em><em>array-like</em><em>, </em><em>array_like</em><em>) or </em><em>'extrapolate'</em>) – <p>(optional)
This argument provided determines if / how extrapolation outside the
given range is handled:</p>
<blockquote>
<div><ul>
<li><p>None: Extrapolation is not performed.</p></li>
<li><p>Single value: This value will be used to fill in for requested
points outside of the data range. If not provided, then the
default is NaN.</p></li>
<li><p>Two-element tuple:  The first element is used as a fill value
for x_new &lt; x[0] and the second element is used for x_new &gt;
x[-1]. Anything that is not a 2-element tuple (e.g., list or
ndarray, regardless of shape) is taken to be a single
array-like argument meant to be used for both bounds as below,
above = fill_value, fill_value.</p></li>
<li><p>If ‘extrapolate’, then points outside the data range will be
extrapolated using the interpolation function.</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>..note:: ‘extrapolate’ is not normally recommended using higher order</dt><dd><p>interpolations due to potential kinks.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – A new 2D array with specified row / columb replaced with x_new and
remaining rows / columns replaced with interpolated values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>AttributeError</strong> – If input array is not 2D.</p></li>
<li><p><strong>ValueError</strong> – On incorrect interpolation axis, independent index, number of
    available datapoints of <cite>x_new</cite> outside data range (for fill_value
    == None).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyavia.data.smooth_multi">
<span class="sig-prename descclassname"><span class="pre">pyavia.data.</span></span><span class="sig-name descname"><span class="pre">smooth_multi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_new</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pyavia.data.smooth_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth multiple equal-length arrays / lists <cite>y</cite> (dependent variables) using
interpolation / extrapolation, taking <cite>x</cite> as the independent variable.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yd</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smooth_multi</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="go">[[3.0, 4.333333333333334, 6.0, 6.0], [10.0, 6.962962962962963, 4.0, 4.0]]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like</em>) – Independent variable array.</p></li>
<li><p><strong>y</strong> (<em>[</em><em>array-like</em><em>, </em><em>...</em><em>]</em>) – One or more equal-length arrays / lists of data which depend on <cite>x</cite>.
Length must be equal to <cite>x</cite>.</p></li>
<li><p><strong>x_new</strong> (<em>array-like</em>) – The result will be interpolated / extrapolated so that the first
array will equal this value.</p></li>
<li><p><strong>kind</strong> (<em>str</em>) – See <code class="docutils literal notranslate"><span class="pre">smooth_array2d()</span></code>.</p></li>
<li><p><strong>fill_value</strong> – See <code class="docutils literal notranslate"><span class="pre">smooth_array2d()</span></code>.  If provided then <code class="docutils literal notranslate"><span class="pre">len(fill_value)</span> <span class="pre">==</span>
<span class="pre">len(y)</span></code> is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – List of smoothed arrays in the same layout as <cite>data</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>[array-like, …]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyavia.data.subd_num_list">
<span class="sig-prename descclassname"><span class="pre">pyavia.data.</span></span><span class="sig-name descname"><span class="pre">subd_num_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">li</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#pyavia.data.subd_num_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands a sorted list of values by repeatedly subdividing the intervals
in the initial list, stopping before <cite>max_size</cite> is exceeded.  This keeps
the originally specified values in position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>li</strong> (<em>list</em><em> or </em><em>array-like</em>) – Starting values.</p></li>
<li><p><strong>max_size</strong> (<em>int</em>) – Upper limit on <code class="docutils literal notranslate"><span class="pre">len(li_dense)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>li_dense</strong> – New list containing subdivided values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Data Manipulation Modules</a><ul>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#module-pyavia.data">Members</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="pyavia.containers.html"
                          title="previous chapter">Containers</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="pyavia.fortran.html"
                          title="next chapter">Fortran</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pyavia.data.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyavia.fortran.html" title="Fortran"
             >next</a> |</li>
        <li class="right" >
          <a href="pyavia.containers.html" title="Containers"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PyAvia 0.0.4 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Data Manipulation Modules</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Eric J. Whitney.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>