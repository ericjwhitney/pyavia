import warnings
from collections import defaultdict

import numpy as np

from pyavia.util.display import Indenter


# Written by Eric J. Whale, January 2023.

# ===========================================================================


def read_XFOIL_polar(filename: str, disp: int | bool = False
                     ) -> (float, float, {str: [float]}):
    """
    Parse the polar data contained in a text file generated by XFOIL.

    Parameters
    ----------
    filename : str
        Filename of text file containing polar data.
    disp : int or bool, optional
        Print information while processing file.  Values >= 1 or `True`
          mean information will be printed.  See
          ``pyavia.util.disp_enter(...)`` for more details.
          XXXX `Indenter` for more details.

    Returns
    -------
    Re, M, data : float, float, {str: [float]}
        - Reynolds number for the data.
        - Mach number for the data.
        - Data table as a dict, with each entry containing one column of
          the data table as a list (all of equal length).  Keys are column
          headings, corresponding to different properties, e.g. ``'a_data',
          'cl_data', 'cm_qc_data'``, etc.  Angles of attack are converted
          to radians.
    """
    # disp_enter(disp)
    indent = Indenter(disp)
    indent2 = Indenter(indent.next_level)

    Re, M = None, None
    cols = []  # XFOIL data column names.
    data = defaultdict(list)

    # Map of XFOIL column names to internal property names.
    prop_map = {
        'alpha': 'α_data',
        'CL': 'cl_data',
        'CD': 'cd_data',
        'CDp': None,  # Flag indicating column to discard.
        'CM': 'cm_qc_data',
        'Top_Xtr': 'xtr_u_data',
        'Bot_Xtr': 'xtr_l_data'
    }

    # See XFOIL source file iopol.f for additional details on parsing
    # these files.
    with open(filename, 'rt') as f:
        # disp_print(f"Loading XFOIL polar from '{filename}':")
        indent(f"Loading XFOIL polar from '{filename}':")

        in_header = True
        for raw_line in f:
            line = raw_line.strip()
            if not line:
                continue  # Skip empty lines.

            if in_header:
                # -- Header Lines -------------------------------------------

                if "Version" in line:
                    # XFOIL Version details.
                    _, ver = line.split("Version")
                    ver = ver.strip()

                    # disp_print(f"\t{'XFOIL Version:':14s} {ver}")
                    indent2(f"{'XFOIL Version:':14s} {ver}")

                    # Issue warning if not in recognised version.
                    if ver not in ('6.99',):
                        warnings.warn(
                            f"XFOIL Version {ver} not recgonised.")

                elif "for:" in line:
                    # Aerofoil name information.
                    _, foilname = line.split("for:")
                    foilname = foilname.strip()

                    # disp_print(f"\t{'Name:':14s} {foilname}")
                    indent2(f"{'Name:':14s} {foilname}")

                elif "Reynolds number" in line or "Mach number" in line:
                    # Reynolds / Mach number scaling information.
                    Re_type, M_type, *_ = line.split()
                    Re_type, M_type = int(Re_type), int(M_type)

                    # Re_type and M_type values mean the following:
                    #   0 = Not given in header (undocumented).
                    #   1 = Re / M fixed.
                    #   2 = Re / M ~ 1/sqrt(cl).
                    #   3 = Re / M ~ 1/cl.

                    # Future Work:At this stage we only support type 1.
                    # We can extend this when required.
                    if Re_type != 1 or M_type != 1:


                        # disp_exit()


                        raise RuntimeError(
                            f"Can't load polar with Reynolds No. type "
                            f"{Re_type}, Mach No. type {M_type}.")

                elif "xtrf" in line:
                    # Forced transition points.  Note: Presently we
                    # just ignore these.
                    pass

                elif ("Mach =" in line or "Re =" in line or
                      "Ncrit =" in line):
                    # Mach No., Reynolds No., Ncrit information.  Note:
                    # This line is badly formatted, so we have to clean
                    # it up. Initially remove all whitespace.
                    clean = ''.join(line.split())

                    # Now insert space before keywords.
                    for kw in ("Mach", "Re", "Ncrit"):
                        clean = clean.replace(kw, ' ' + kw)

                    # Finally strip any leading spaces we may have added.
                    clean = clean.strip()

                    # Now separately process each part of the string.
                    for part in clean.split():
                        tokens = part.split('=')
                        if len(tokens) != 2:


                            # disp_exit()



                            raise RuntimeError(
                                f"Expecting Re, M, Ncrit but got "
                                f"unknown substring: {part}")

                        if tokens[0] == "Mach":
                            M = float(tokens[1])
                        elif tokens[0] == "Re":
                            Re = float(tokens[1])
                        elif tokens[0] == "Ncrit":
                            pass  # Presently ignore this detail.
                        else:

                            # disp_exit()


                            raise RuntimeError(
                                f"Expecting Re, M, Ncrit but got "
                                f"unknown parameter: {tokens[0]}")

                    # disp_print(f"\t{'Re:':14s} {Re:.03E}")
                    # disp_print(f"\t{'M:':14s} {M:.03f}")
                    indent2(f"{'Re:':14s} {Re:.03E}")
                    indent2(f"{'M:':14s} {M:.03f}")

                elif "alpha" in line:
                    # Start of the data table.  Change status to
                    # allow fall-thru.
                    in_header = False

                else:

                    # disp_exit()


                    raise RuntimeError(f"Unknown line encountered: {line}")

            if in_header:
                continue

            # -- Data Table Lines -------------------------------------------

            if "alpha" in line:
                # Setup data table.

                if cols:  # Already setup?

                    # disp_exit()


                    raise RuntimeError(
                        f"Mysterious second table header line found o.O")

                cols = line.split()

                # disp_print(f"\t{'Columns:':14s} " + ", ".join(cols))
                indent2(f"{'Columns:':14s} " + ", ".join(cols))


            elif "---" in line:
                # Skip separator line.
                pass

            else:
                # Line of values.  Iterate over keys because dictionaries
                # preserve insertion order.
                for col, val in zip(cols, line.split(), strict=True):
                    # Find property name from column name.
                    try:
                        prop = prop_map[col]
                    except KeyError:


                        # disp_exit()


                        raise RuntimeError(f"Unknown column '{col}'.")

                    if prop is None:
                        # Discard this column.
                        pass

                    elif prop != 'α_data':
                        # Regular values.
                        data[prop].append(float(val))

                    else:
                        # Convert [°] -> [radians].
                        data[prop].append(np.deg2rad(float(val)))

        # File loading complete.

    # Fail if we didn't get Re, M or any data.
    if Re is None or M is None:


        # disp_exit()


        raise RuntimeError("Failed to find Re or M.")

    if not data:


        # disp_exit()


        raise RuntimeError("No polar data was found.")

    # disp_print(f"\t{'Datapoints:':14s} {len(data['α_data'])}")
    indent2(f"\t{'Datapoints:':14s} {len(data['α_data'])}")

    # disp_exit()



    return Re, M, data


# ---------------------------------------------------------------------------
